# Reading SILGenFunction::emitValueConstructor

## Summary

**1st Step**: The function checks if it is an implicit member-wise initializer. If it is, then dispatch to `emitImplicitValueConstructor`

**2nd Step**: The function emits allocation of local variables for `self` with cleanup.

**3rd Step**: The function emits the prolog.

**4th Step**: The function emits constructor metatype arg

**5th Step**: The function **optionally** emits codes to make sure the function itself hopped to the right global anctor, if:
- it is async
- and the hops not injected by definite init.

**6th Step**: The function **optionally** emits failure exit basic block if it is failurable

**7th Step** The function **optionally** emits member initializers if it is not delegating.

**8th Step** The function emits profiler increment.

**9th Step** The function emits bodyâ€™s statement.

**10th Step** The function builds the epilog basic block, since the AST representation of the constructor decl (which has no self in the return type) doesn't match the SIL representation.

**11st Step** The function emits the epilog.

**12nd Step** The function emits return.

## Prototype

`void SILGenFunction::emitValueConstructor(ConstructorDecl *)`
## Process

CONDITIONAL EARLY-RETURN: `emitImplicitValueConstructor` IF `ctor->isMemberwiseInitializer()`

EVALUATE: `isDelegating` <- `ctor->getDelegatingOrChainedInitKind().initKind == BodyInitKind::Delegating`

EVALUATE: `auto &lowering` <- `getTypeLowering(selfDecl->getType())`

EVALUATE: `MarkUninitializedInst MUIKind`
>Decide if we need to do extra work to warn on unsafe behavior in pre-Swift-5 modes.

EXECUTE: `emitLocalVariableWithCleanup(selfDecl, MUIKind)->finishInitialization(*this);`
> Allocate the local variable for 'self'.

EXECUTE: `emitBasicProlog`
EXECUTE: `emitConstructorMetatypeArg`
> Emit the prolog.

EXECUTE: `emitConstructorPrologActorHop`
	IF `ctor->hasAsync()` && `ctorHopsInjectedByDefiniteInit`
> Make sure we've hopped to the right global actor, if any.
> If it's not injected by definite init, we do it in the prologue now.

EXECUTE: `prepareEpilog`
>Create a basic block to jump to for the implicit 'self' return.
>We won't emit this until after we've emitted the body.
>The epilog takes a void return because the return of 'self' is implicit.

IF `ctor->isFailable()`

  EXECUTE: failureBB <- `createBasicBlock`
  EXECUTE: savedIP <- `SILGenSavedInsertionPoint(...)`
  EXECUTE: failureExitBB <- `createBasicBlock`
  EXECUTE: `Cleanups.emitCleanupsForReturn`
  >`Cleanups` is a member variable of type `swift::lowering::CleanupManager` of `SILGenFunction`

DECLARE: `failureExitBB` AS `SILBasicBlock *`
DECLARE: `failureExitArg` AS `SILArgument *`

  IF `F.getConventions().hasIndirectSILResults()`:
    EXECUTE: `B.createInjectEnumAddr`
    EXECUTE: `B.createBranch`
    EXECUTE: `B.setInsertionPoint`
    EXECUTE: `B.createReturn`
ELSE:
    EXECUTE: `failureExitArg` <-` createPhiArgument`
    EXECUTE: `nilResult` <- `B.createEnum`
    EXECUTE: `B.createBranch`
    EXECUTE: `setInsertionPoint`
    EXECUTE: `createReturn`
>`F` is a member variable of type `SILGenFunction &` and declared in `SILGenFunction`
>`B` is a member variable of type `SILGenBuilder` and declared in `SILGenFunction`

  EXECUTE: `FailDest` <- `JumpDest(...)`

IF `!isDelegating`:
  EXECUTE: `emitMemberInitializers`

EXECUTE: `emitProfilerIncrement`
EXECUTE: `emitStmt`

DECLARE: `selfValue` AS `SILValue`
  EXECUTE: `savedIP` <- `SILGenSavedInsertionPoint(...`)
  EXECUTE: `cleanupLoc` <- `CleanupLocation(ctor)`
  
 IF `!F.getConventions().hasIndirectSILResults()`
   EXECUTE: `selfValue` <- `lowering.emitLoad`
   IF `ctor->isFailable()`
     EXECUTE: `selfValue` <- `B.createEnum`
 ELSE:
    EXECUTE: `completeReturnAddress` <- `F.getIndirectResults()[0]`
    DECLARE: `returnAddress` AS `SILValue`
    IF `!ctor->isFailable()`:
      EXECUTE `returnAddress` <- `completeReturnAddress`
    ELSE:
      EXECUTE `returnAddress` <- `B.createInitEnumDataAddr`
    EXECUTE `B.createCopyAddr`
    IF `!ctor->isFailable()`:
      EXECUTE `B.createInjectEnumAddr`

>Build a custom epilog block, since the AST representation of the constructor decl (which has no self in the return type) doesn't match the SIL representation.

EXECUTE: `returnLoc` <- `emitEpilog`

IF: `B.hasValidInsertionPoint()`:
  IF `!failureExitBB`:
    IF `!selfValue`:
      DECLARE: `loc` AS `SILLocation` <- `SILLocation(ctor)`
      EXECUTE: `loc.markAutoGenerated()`
      EXECUTE: `selfValue` <- `emitEmptyTuple(loc)`
    EXECUTE: `B.createReturn`
  ELSE:
    IF `selfValue`:
      EXECUTE: `B.createBranch(returnLoc, failureExitBB, selfValue)`
    ELSE:
      EXECUTE: `B.createBranch(returnLoc, failureExitBB)`

 ## Outline

1. Early return for implicit memberwise initializer (no custom logics, not failable, compiler generated code)

2. Emit local variable with cleanup

3. Emit the prolog basic block

4. Ensure hopped to the right global actor if it is an `async` function

5. Prepare epilog (return destination)

6. Create failure exit basic block & set failure destination for failable initializer

7. Emit member-wise initializer if the initializer is not delegating to another

8. Emit body statement

9. Build a custom epilog basic block other than the AST representation
>The AST representable does not have return value but the SIL representation have

10. Emit epilog